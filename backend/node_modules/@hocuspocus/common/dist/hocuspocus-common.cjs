'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* eslint-env browser */
const BIT8 = 128;
const BITS7 = 127;

/**
 * Efficient schema-less binary decoding with support for variable length encoding.
 *
 * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = new encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = new decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module decoding
 */

/**
 * Read one byte as unsigned integer.
 * @function
 * @param {Decoder} decoder The decoder instance
 * @return {number} Unsigned 8-bit integer
 */
const readUint8 = decoder => decoder.arr[decoder.pos++];

/**
 * Read unsigned integer (32bit) with variable length.
 * 1/8th of the storage is used as encoding overhead.
 *  * numbers < 2^7 is stored in one bytlength
 *  * numbers < 2^14 is stored in two bylength
 *
 * @function
 * @param {Decoder} decoder
 * @return {number} An unsigned integer.length
 */
const readVarUint = decoder => {
  let num = 0;
  let len = 0;
  while (true) {
    const r = decoder.arr[decoder.pos++];
    num = num | ((r & BITS7) << len);
    len += 7;
    if (r < BIT8) {
      return num >>> 0 // return unsigned number!
    }
    /* istanbul ignore if */
    if (len > 35) {
      throw new Error('Integer out of range!')
    }
  }
};

/**
 * Read string of variable length
 * * varUint is used to store the length of the string
 *
 * Transforming utf8 to a string is pretty expensive. The code performs 10x better
 * when String.fromCodePoint is fed with all characters as arguments.
 * But most environments have a maximum number of arguments per functions.
 * For effiency reasons we apply a maximum of 10000 characters at once.
 *
 * @function
 * @param {Decoder} decoder
 * @return {String} The read String.
 */
const readVarString = decoder => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return ''
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen
    if (--remainingLen < 100) { // do not create a Uint8Array for small strings
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 10000 ? remainingLen : 10000;
        // this is dangerous, we create a fresh array view from the existing buffer
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        // Starting with ES5.1 we can supply a generic array-like object as arguments
        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString))
  }
};

/**
 * Efficient schema-less binary encoding with support for variable length encoding.
 *
 * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = new encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = new decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module encoding
 */

/**
 * Write one byte to the encoder.
 *
 * @function
 * @param {Encoder} encoder
 * @param {number} num The byte that is to be encoded.
 */
const write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};

/**
 * Write a variable length unsigned integer.
 *
 * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)
 *
 * @function
 * @param {Encoder} encoder
 * @param {number} num The number that is to be encoded.
 */
const writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | (BITS7 & num));
    num >>>= 7;
  }
  write(encoder, BITS7 & num);
};

/**
 * Write a variable length string.
 *
 * @function
 * @param {Encoder} encoder
 * @param {String} str The string that is to be encoded.
 */
const writeVarString = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));
  }
};

var AuthMessageType;
(function (AuthMessageType) {
    AuthMessageType[AuthMessageType["Token"] = 0] = "Token";
    AuthMessageType[AuthMessageType["PermissionDenied"] = 1] = "PermissionDenied";
    AuthMessageType[AuthMessageType["Authenticated"] = 2] = "Authenticated";
})(AuthMessageType || (AuthMessageType = {}));
const writeAuthentication = (encoder, auth) => {
    writeVarUint(encoder, AuthMessageType.Token);
    writeVarString(encoder, auth);
};
const writePermissionDenied = (encoder, reason) => {
    writeVarUint(encoder, AuthMessageType.PermissionDenied);
    writeVarString(encoder, reason);
};
const writeAuthenticated = (encoder) => {
    writeVarUint(encoder, AuthMessageType.Authenticated);
};
const readAuthMessage = (decoder, permissionDeniedHandler, authenticatedHandler) => {
    switch (readVarUint(decoder)) {
        case AuthMessageType.PermissionDenied: {
            permissionDeniedHandler(readVarString(decoder));
            break;
        }
        case AuthMessageType.Authenticated: {
            authenticatedHandler();
            break;
        }
    }
};

/**
 * The server successfully processed the request, asks that the requester reset
 * its document view, and is not returning any content.
 */
const ResetConnection = {
    code: 4205,
    reason: 'Reset Connection',
};
/**
 * Similar to Forbidden, but specifically for use when authentication is required and has
 * failed or has not yet been provided.
 */
const Unauthorized = {
    code: 4401,
    reason: 'Unauthorized',
};
/**
 * The request contained valid data and was understood by the server, but the server
 * is refusing action.
 */
const Forbidden = {
    code: 4403,
    reason: 'Forbidden',
};
/**
 * The server timed out waiting for the request.
 */
const ConnectionTimeout = {
    code: 4408,
    reason: 'Connection Timeout',
};

const awarenessStatesToArray = (states) => {
    return Array.from(states.entries()).map(([key, value]) => {
        return {
            clientId: key,
            ...value,
        };
    });
};

/**
 * State of the WebSocket connection.
 * https://developer.mozilla.org/de/docs/Web/API/WebSocket/readyState
 */
exports.WsReadyStates = void 0;
(function (WsReadyStates) {
    WsReadyStates[WsReadyStates["Connecting"] = 0] = "Connecting";
    WsReadyStates[WsReadyStates["Open"] = 1] = "Open";
    WsReadyStates[WsReadyStates["Closing"] = 2] = "Closing";
    WsReadyStates[WsReadyStates["Closed"] = 3] = "Closed";
})(exports.WsReadyStates || (exports.WsReadyStates = {}));

exports.ConnectionTimeout = ConnectionTimeout;
exports.Forbidden = Forbidden;
exports.ResetConnection = ResetConnection;
exports.Unauthorized = Unauthorized;
exports.awarenessStatesToArray = awarenessStatesToArray;
exports.readAuthMessage = readAuthMessage;
exports.writeAuthenticated = writeAuthenticated;
exports.writeAuthentication = writeAuthentication;
exports.writePermissionDenied = writePermissionDenied;
//# sourceMappingURL=hocuspocus-common.cjs.map
